{"ast":null,"code":"import { AbiFunctionSignatureNotFoundError } from '../../errors/abi.js';\nimport { slice } from '../data/slice.js';\nimport { getFunctionSelector } from '../hash/getFunctionSelector.js';\nimport { decodeAbiParameters } from './decodeAbiParameters.js';\nimport { formatAbiItem } from './formatAbiItem.js';\nexport function decodeFunctionData(_ref) {\n  let {\n    abi,\n    data\n  } = _ref;\n  const signature = slice(data, 0, 4);\n  const description = abi.find(x => x.type === 'function' && signature === getFunctionSelector(formatAbiItem(x)));\n  if (!description) throw new AbiFunctionSignatureNotFoundError(signature, {\n    docsPath: '/docs/contract/decodeFunctionData'\n  });\n  return {\n    functionName: description.name,\n    args: 'inputs' in description && description.inputs && description.inputs.length > 0 ? decodeAbiParameters(description.inputs, slice(data, 4)) : undefined\n  };\n}","map":{"version":3,"names":["AbiFunctionSignatureNotFoundError","slice","getFunctionSelector","decodeAbiParameters","formatAbiItem","decodeFunctionData","_ref","abi","data","signature","description","find","x","type","docsPath","functionName","name","args","inputs","length","undefined"],"sources":["/Users/kanaiyuuta/Downloads/test-yuuta-main/node_modules/viem/utils/abi/decodeFunctionData.ts"],"sourcesContent":["import type { Abi, ExtractAbiFunctionNames } from 'abitype'\n\nimport { AbiFunctionSignatureNotFoundError } from '../../errors/abi.js'\nimport type { GetFunctionArgs } from '../../types/contract.js'\nimport type { Hex } from '../../types/misc.js'\nimport { slice } from '../data/slice.js'\nimport { getFunctionSelector } from '../hash/getFunctionSelector.js'\n\nimport { decodeAbiParameters } from './decodeAbiParameters.js'\nimport { formatAbiItem } from './formatAbiItem.js'\n\nexport type DecodeFunctionDataParameters<\n  TAbi extends Abi | readonly unknown[] = Abi,\n> = {\n  abi: TAbi\n  data: Hex\n}\n\nexport type DecodeFunctionDataReturnType<\n  TAbi extends Abi | readonly unknown[] = Abi,\n  _FunctionNames extends string = TAbi extends Abi\n    ? Abi extends TAbi\n      ? string\n      : ExtractAbiFunctionNames<TAbi>\n    : string,\n> = {\n  [TName in _FunctionNames]: {\n    args: GetFunctionArgs<TAbi, TName>['args']\n    functionName: TName\n  }\n}[_FunctionNames]\n\nexport function decodeFunctionData<TAbi extends Abi | readonly unknown[]>({\n  abi,\n  data,\n}: DecodeFunctionDataParameters<TAbi>) {\n  const signature = slice(data, 0, 4)\n  const description = (abi as Abi).find(\n    (x) =>\n      x.type === 'function' &&\n      signature === getFunctionSelector(formatAbiItem(x)),\n  )\n  if (!description)\n    throw new AbiFunctionSignatureNotFoundError(signature, {\n      docsPath: '/docs/contract/decodeFunctionData',\n    })\n  return {\n    functionName: (description as { name: string }).name,\n    args: ('inputs' in description &&\n    description.inputs &&\n    description.inputs.length > 0\n      ? decodeAbiParameters(description.inputs, slice(data, 4))\n      : undefined) as readonly unknown[] | undefined,\n  } as DecodeFunctionDataReturnType<TAbi>\n}\n"],"mappings":"AAEA,SAASA,iCAAiC,QAAQ,qBAAqB;AAGvE,SAASC,KAAK,QAAQ,kBAAkB;AACxC,SAASC,mBAAmB,QAAQ,gCAAgC;AAEpE,SAASC,mBAAmB,QAAQ,0BAA0B;AAC9D,SAASC,aAAa,QAAQ,oBAAoB;AAuBlD,OAAM,SAAUC,kBAAkBA,CAAAC,IAAA,EAGG;EAAA,IAHqC;IACxEC,GAAG;IACHC;EAAI,CAC+B,GAAAF,IAAA;EACnC,MAAMG,SAAS,GAAGR,KAAK,CAACO,IAAI,EAAE,CAAC,EAAE,CAAC,CAAC;EACnC,MAAME,WAAW,GAAIH,GAAW,CAACI,IAAI,CAClCC,CAAC,IACAA,CAAC,CAACC,IAAI,KAAK,UAAU,IACrBJ,SAAS,KAAKP,mBAAmB,CAACE,aAAa,CAACQ,CAAC,CAAC,CAAC,CACtD;EACD,IAAI,CAACF,WAAW,EACd,MAAM,IAAIV,iCAAiC,CAACS,SAAS,EAAE;IACrDK,QAAQ,EAAE;GACX,CAAC;EACJ,OAAO;IACLC,YAAY,EAAGL,WAAgC,CAACM,IAAI;IACpDC,IAAI,EAAG,QAAQ,IAAIP,WAAW,IAC9BA,WAAW,CAACQ,MAAM,IAClBR,WAAW,CAACQ,MAAM,CAACC,MAAM,GAAG,CAAC,GACzBhB,mBAAmB,CAACO,WAAW,CAACQ,MAAM,EAAEjB,KAAK,CAACO,IAAI,EAAE,CAAC,CAAC,CAAC,GACvDY;GACiC;AACzC"},"metadata":{},"sourceType":"module","externalDependencies":[]}