{"ast":null,"code":"export function execTyped(regex, string) {\n  const match = regex.exec(string);\n  return match === null || match === void 0 ? void 0 : match.groups;\n}\nexport const bytesRegex = /^bytes([1-9]|1[0-9]|2[0-9]|3[0-2])?$/;\nexport const integerRegex = /^u?int(8|16|24|32|40|48|56|64|72|80|88|96|104|112|120|128|136|144|152|160|168|176|184|192|200|208|216|224|232|240|248|256)?$/;\nexport const isTupleRegex = /^\\(.+?\\).*?$/;","map":{"version":3,"names":["execTyped","regex","string","match","exec","groups","bytesRegex","integerRegex","isTupleRegex"],"sources":["/Users/kanaiyuuta/Downloads/test-yuuta-main/node_modules/viem/node_modules/abitype/src/regex.ts"],"sourcesContent":["// TODO: This looks cool. Need to check the performance of `new RegExp` versus defined inline though.\n// https://twitter.com/GabrielVergnaud/status/1622906834343366657\nexport function execTyped<T>(regex: RegExp, string: string) {\n  const match = regex.exec(string)\n  return match?.groups as T | undefined\n}\n\n// `bytes<M>`: binary type of `M` bytes, `0 < M <= 32`\n// https://regexr.com/6va55\nexport const bytesRegex = /^bytes([1-9]|1[0-9]|2[0-9]|3[0-2])?$/\n\n// `(u)int<M>`: (un)signed integer type of `M` bits, `0 < M <= 256`, `M % 8 == 0`\n// https://regexr.com/6v8hp\nexport const integerRegex =\n  /^u?int(8|16|24|32|40|48|56|64|72|80|88|96|104|112|120|128|136|144|152|160|168|176|184|192|200|208|216|224|232|240|248|256)?$/\n\nexport const isTupleRegex = /^\\(.+?\\).*?$/\n"],"mappings":"AAEA,OAAM,SAAUA,SAASA,CAAIC,KAAa,EAAEC,MAAc;EACxD,MAAMC,KAAK,GAAGF,KAAK,CAACG,IAAI,CAACF,MAAM,CAAC;EAChC,OAAOC,KAAK,aAALA,KAAK,uBAALA,KAAK,CAAEE,MAAuB;AACvC;AAIA,OAAO,MAAMC,UAAU,GAAG,sCAAsC;AAIhE,OAAO,MAAMC,YAAY,GACvB,8HAA8H;AAEhI,OAAO,MAAMC,YAAY,GAAG,cAAc"},"metadata":{},"sourceType":"module","externalDependencies":[]}