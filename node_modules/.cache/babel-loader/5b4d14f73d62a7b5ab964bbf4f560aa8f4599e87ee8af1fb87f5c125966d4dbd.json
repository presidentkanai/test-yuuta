{"ast":null,"code":"import { getAction } from '../../utils/getAction.js';\nimport { observe } from '../../utils/observe.js';\nimport { poll } from '../../utils/poll.js';\nimport { stringify } from '../../utils/stringify.js';\nimport { createPendingTransactionFilter } from './createPendingTransactionFilter.js';\nimport { getFilterChanges } from './getFilterChanges.js';\nimport { uninstallFilter } from './uninstallFilter.js';\n/**\n * Watches and returns pending transaction hashes.\n *\n * - Docs: https://viem.sh/docs/actions/public/watchPendingTransactions.html\n * - JSON-RPC Methods:\n *   - When `poll: true`\n *     - Calls [`eth_newPendingTransactionFilter`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_newpendingtransactionfilter) to initialize the filter.\n *     - Calls [`eth_getFilterChanges`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getFilterChanges) on a polling interval.\n *   - When `poll: false` & WebSocket Transport, uses a WebSocket subscription via [`eth_subscribe`](https://docs.alchemy.com/reference/eth-subscribe-polygon) and the `\"newPendingTransactions\"` event.\n *\n * This Action will batch up all the pending transactions found within the [`pollingInterval`](https://viem.sh/docs/actions/public/watchPendingTransactions.html#pollinginterval-optional), and invoke them via [`onTransactions`](https://viem.sh/docs/actions/public/watchPendingTransactions.html#ontransactions).\n *\n * @param client - Client to use\n * @param parameters - {@link WatchPendingTransactionsParameters}\n * @returns A function that can be invoked to stop watching for new pending transaction hashes. {@link WatchPendingTransactionsReturnType}\n *\n * @example\n * import { createPublicClient, http } from 'viem'\n * import { mainnet } from 'viem/chains'\n * import { watchPendingTransactions } from 'viem/public'\n *\n * const client = createPublicClient({\n *   chain: mainnet,\n *   transport: http(),\n * })\n * const unwatch = await watchPendingTransactions(client, {\n *   onTransactions: (hashes) => console.log(hashes),\n * })\n */\nexport function watchPendingTransactions(client, _ref) {\n  let {\n    batch = true,\n    onError,\n    onTransactions,\n    poll: poll_,\n    pollingInterval = client.pollingInterval\n  } = _ref;\n  const enablePolling = typeof poll_ !== 'undefined' ? poll_ : client.transport.type !== 'webSocket';\n  const pollPendingTransactions = () => {\n    const observerId = stringify(['watchPendingTransactions', client.uid, batch, pollingInterval]);\n    return observe(observerId, {\n      onTransactions,\n      onError\n    }, emit => {\n      let filter;\n      const unwatch = poll(async () => {\n        try {\n          if (!filter) {\n            try {\n              filter = await getAction(client, createPendingTransactionFilter, 'createPendingTransactionFilter')({});\n              return;\n            } catch (err) {\n              unwatch();\n              throw err;\n            }\n          }\n          const hashes = await getAction(client, getFilterChanges, 'getFilterChanges')({\n            filter\n          });\n          if (hashes.length === 0) return;\n          if (batch) emit.onTransactions(hashes);else for (const hash of hashes) emit.onTransactions([hash]);\n        } catch (err) {\n          var _emit$onError;\n          (_emit$onError = emit.onError) === null || _emit$onError === void 0 || _emit$onError.call(emit, err);\n        }\n      }, {\n        emitOnBegin: true,\n        interval: pollingInterval\n      });\n      return async () => {\n        if (filter) await getAction(client, uninstallFilter, 'uninstallFilter')({\n          filter\n        });\n        unwatch();\n      };\n    });\n  };\n  const subscribePendingTransactions = () => {\n    let active = true;\n    let unsubscribe = () => active = false;\n    (async () => {\n      try {\n        const {\n          unsubscribe: unsubscribe_\n        } = await client.transport.subscribe({\n          params: ['newPendingTransactions'],\n          onData(data) {\n            if (!active) return;\n            const transaction = data.result;\n            onTransactions([transaction]);\n          },\n          onError(error) {\n            onError === null || onError === void 0 || onError(error);\n          }\n        });\n        unsubscribe = unsubscribe_;\n        if (!active) unsubscribe();\n      } catch (err) {\n        onError === null || onError === void 0 || onError(err);\n      }\n    })();\n    return unsubscribe;\n  };\n  return enablePolling ? pollPendingTransactions() : subscribePendingTransactions();\n}","map":{"version":3,"names":["getAction","observe","poll","stringify","createPendingTransactionFilter","getFilterChanges","uninstallFilter","watchPendingTransactions","client","_ref","batch","onError","onTransactions","poll_","pollingInterval","enablePolling","transport","type","pollPendingTransactions","observerId","uid","emit","filter","unwatch","err","hashes","length","hash","_emit$onError","call","emitOnBegin","interval","subscribePendingTransactions","active","unsubscribe","unsubscribe_","subscribe","params","onData","data","transaction","result","error"],"sources":["C:\\Users\\takap\\OneDrive - Chiba Institute of Technology\\デスクトップ\\web3-sotuken\\node_modules\\viem\\actions\\public\\watchPendingTransactions.ts"],"sourcesContent":["import type { Client } from '../../clients/createClient.js'\nimport type { Transport } from '../../clients/transports/createTransport.js'\nimport type { ErrorType } from '../../errors/utils.js'\nimport type { Chain } from '../../types/chain.js'\nimport type { Filter } from '../../types/filter.js'\nimport type { Hash } from '../../types/misc.js'\nimport type { GetTransportConfig } from '../../types/transport.js'\nimport { getAction } from '../../utils/getAction.js'\nimport { type ObserveErrorType, observe } from '../../utils/observe.js'\nimport { poll } from '../../utils/poll.js'\nimport { type StringifyErrorType, stringify } from '../../utils/stringify.js'\n\nimport { createPendingTransactionFilter } from './createPendingTransactionFilter.js'\nimport { getFilterChanges } from './getFilterChanges.js'\nimport { uninstallFilter } from './uninstallFilter.js'\n\nexport type OnTransactionsParameter = Hash[]\nexport type OnTransactionsFn = (transactions: OnTransactionsParameter) => void\n\ntype PollOptions = {\n  /**\n   * Whether or not the transaction hashes should be batched on each invocation.\n   * @default true\n   */\n  batch?: boolean\n  /**\n   * Polling frequency (in ms). Defaults to Client's pollingInterval config.\n   * @default client.pollingInterval\n   */\n  pollingInterval?: number\n}\n\nexport type WatchPendingTransactionsParameters<\n  TTransport extends Transport = Transport,\n> = {\n  /** The callback to call when an error occurred when trying to get for a new block. */\n  onError?: (error: Error) => void\n  /** The callback to call when new transactions are received. */\n  onTransactions: OnTransactionsFn\n} & (GetTransportConfig<TTransport>['type'] extends 'webSocket'\n  ?\n      | {\n          batch?: never\n          /**\n           * Whether or not the WebSocket Transport should poll the JSON-RPC, rather than using `eth_subscribe`.\n           * @default false\n           */\n          poll?: false\n          pollingInterval?: never\n        }\n      | (PollOptions & {\n          /**\n           * Whether or not the WebSocket Transport should poll the JSON-RPC, rather than using `eth_subscribe`.\n           * @default true\n           */\n          poll?: true\n        })\n  : PollOptions & {\n      poll?: true\n    })\n\nexport type WatchPendingTransactionsReturnType = () => void\n\nexport type WatchPendingTransactionsErrorType =\n  | StringifyErrorType\n  | ObserveErrorType\n  | ErrorType\n\n/**\n * Watches and returns pending transaction hashes.\n *\n * - Docs: https://viem.sh/docs/actions/public/watchPendingTransactions.html\n * - JSON-RPC Methods:\n *   - When `poll: true`\n *     - Calls [`eth_newPendingTransactionFilter`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_newpendingtransactionfilter) to initialize the filter.\n *     - Calls [`eth_getFilterChanges`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getFilterChanges) on a polling interval.\n *   - When `poll: false` & WebSocket Transport, uses a WebSocket subscription via [`eth_subscribe`](https://docs.alchemy.com/reference/eth-subscribe-polygon) and the `\"newPendingTransactions\"` event.\n *\n * This Action will batch up all the pending transactions found within the [`pollingInterval`](https://viem.sh/docs/actions/public/watchPendingTransactions.html#pollinginterval-optional), and invoke them via [`onTransactions`](https://viem.sh/docs/actions/public/watchPendingTransactions.html#ontransactions).\n *\n * @param client - Client to use\n * @param parameters - {@link WatchPendingTransactionsParameters}\n * @returns A function that can be invoked to stop watching for new pending transaction hashes. {@link WatchPendingTransactionsReturnType}\n *\n * @example\n * import { createPublicClient, http } from 'viem'\n * import { mainnet } from 'viem/chains'\n * import { watchPendingTransactions } from 'viem/public'\n *\n * const client = createPublicClient({\n *   chain: mainnet,\n *   transport: http(),\n * })\n * const unwatch = await watchPendingTransactions(client, {\n *   onTransactions: (hashes) => console.log(hashes),\n * })\n */\nexport function watchPendingTransactions<\n  TTransport extends Transport,\n  TChain extends Chain | undefined,\n>(\n  client: Client<TTransport, TChain>,\n  {\n    batch = true,\n    onError,\n    onTransactions,\n    poll: poll_,\n    pollingInterval = client.pollingInterval,\n  }: WatchPendingTransactionsParameters<TTransport>,\n) {\n  const enablePolling =\n    typeof poll_ !== 'undefined' ? poll_ : client.transport.type !== 'webSocket'\n\n  const pollPendingTransactions = () => {\n    const observerId = stringify([\n      'watchPendingTransactions',\n      client.uid,\n      batch,\n      pollingInterval,\n    ])\n    return observe(observerId, { onTransactions, onError }, (emit) => {\n      let filter: Filter<'transaction'>\n\n      const unwatch = poll(\n        async () => {\n          try {\n            if (!filter) {\n              try {\n                filter = await getAction(\n                  client,\n                  createPendingTransactionFilter,\n                  'createPendingTransactionFilter',\n                )({})\n                return\n              } catch (err) {\n                unwatch()\n                throw err\n              }\n            }\n\n            const hashes = await getAction(\n              client,\n              getFilterChanges,\n              'getFilterChanges',\n            )({ filter })\n            if (hashes.length === 0) return\n            if (batch) emit.onTransactions(hashes)\n            else for (const hash of hashes) emit.onTransactions([hash])\n          } catch (err) {\n            emit.onError?.(err as Error)\n          }\n        },\n        {\n          emitOnBegin: true,\n          interval: pollingInterval,\n        },\n      )\n\n      return async () => {\n        if (filter)\n          await getAction(\n            client,\n            uninstallFilter,\n            'uninstallFilter',\n          )({ filter })\n        unwatch()\n      }\n    })\n  }\n\n  const subscribePendingTransactions = () => {\n    let active = true\n    let unsubscribe = () => (active = false)\n    ;(async () => {\n      try {\n        const { unsubscribe: unsubscribe_ } = await client.transport.subscribe({\n          params: ['newPendingTransactions'],\n          onData(data: any) {\n            if (!active) return\n            const transaction = data.result\n            onTransactions([transaction])\n          },\n          onError(error: Error) {\n            onError?.(error)\n          },\n        })\n        unsubscribe = unsubscribe_\n        if (!active) unsubscribe()\n      } catch (err) {\n        onError?.(err as Error)\n      }\n    })()\n    return unsubscribe\n  }\n\n  return enablePolling\n    ? pollPendingTransactions()\n    : subscribePendingTransactions()\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}