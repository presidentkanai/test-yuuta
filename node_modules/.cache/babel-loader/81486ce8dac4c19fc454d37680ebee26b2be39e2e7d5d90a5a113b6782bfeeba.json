{"ast":null,"code":"const schedulerCache = /*#__PURE__*/new Map();\nexport function createBatchScheduler(_ref) {\n  let {\n    fn,\n    id,\n    shouldSplitBatch,\n    wait = 0\n  } = _ref;\n  const exec = async () => {\n    const scheduler = getScheduler();\n    flush();\n    const args = scheduler.map(_ref2 => {\n      let {\n        args\n      } = _ref2;\n      return args;\n    });\n    if (args.length === 0) return;\n    fn(args).then(data => {\n      scheduler.forEach((_ref3, i) => {\n        var _pendingPromise$resol;\n        let {\n          pendingPromise\n        } = _ref3;\n        return (_pendingPromise$resol = pendingPromise.resolve) === null || _pendingPromise$resol === void 0 ? void 0 : _pendingPromise$resol.call(pendingPromise, [data[i], data]);\n      });\n    }).catch(err => {\n      scheduler.forEach(_ref4 => {\n        var _pendingPromise$rejec;\n        let {\n          pendingPromise\n        } = _ref4;\n        return (_pendingPromise$rejec = pendingPromise.reject) === null || _pendingPromise$rejec === void 0 ? void 0 : _pendingPromise$rejec.call(pendingPromise, err);\n      });\n    });\n  };\n  const flush = () => schedulerCache.delete(id);\n  const getBatchedArgs = () => getScheduler().map(_ref5 => {\n    let {\n      args\n    } = _ref5;\n    return args;\n  });\n  const getScheduler = () => schedulerCache.get(id) || [];\n  const setScheduler = item => schedulerCache.set(id, [...getScheduler(), item]);\n  return {\n    flush,\n    async schedule(args) {\n      const pendingPromise = {};\n      const promise = new Promise((resolve, reject) => {\n        pendingPromise.resolve = resolve;\n        pendingPromise.reject = reject;\n      });\n      const split = shouldSplitBatch === null || shouldSplitBatch === void 0 ? void 0 : shouldSplitBatch([...getBatchedArgs(), args]);\n      if (split) exec();\n      const hasActiveScheduler = getScheduler().length > 0;\n      if (hasActiveScheduler) {\n        setScheduler({\n          args,\n          pendingPromise\n        });\n        return promise;\n      }\n      setScheduler({\n        args,\n        pendingPromise\n      });\n      setTimeout(exec, wait);\n      return promise;\n    }\n  };\n}","map":{"version":3,"names":["schedulerCache","Map","createBatchScheduler","_ref","fn","id","shouldSplitBatch","wait","exec","scheduler","getScheduler","flush","args","map","_ref2","length","then","data","forEach","_ref3","i","_pendingPromise$resol","pendingPromise","resolve","call","catch","err","_ref4","_pendingPromise$rejec","reject","delete","getBatchedArgs","_ref5","get","setScheduler","item","set","schedule","promise","Promise","split","hasActiveScheduler","setTimeout"],"sources":["/Users/kanaiyuuta/Downloads/test-yuuta-main/node_modules/viem/utils/promise/createBatchScheduler.ts"],"sourcesContent":["type Resolved<TReturnType extends readonly unknown[] = any> = [\n  result: TReturnType[number],\n  results: TReturnType,\n]\n\ntype PendingPromise<TReturnType extends readonly unknown[] = any> = {\n  resolve?: (data: Resolved<TReturnType>) => void\n  reject?: (reason?: unknown) => void\n}\n\ntype SchedulerItem = { args: unknown; pendingPromise: PendingPromise }\n\nexport type CreateBatchSchedulerArguments<\n  TParameters = unknown,\n  TReturnType extends readonly unknown[] = readonly unknown[],\n> = {\n  fn: (args: TParameters[]) => Promise<TReturnType>\n  id: number | string\n  shouldSplitBatch?: (args: TParameters[]) => boolean\n  wait?: number\n}\nexport type CreateBatchSchedulerReturnType<\n  TParameters = unknown,\n  TReturnType extends readonly unknown[] = readonly unknown[],\n> = {\n  flush: () => void\n  schedule: TParameters extends undefined\n    ? (args?: TParameters) => Promise<Resolved<TReturnType>>\n    : (args: TParameters) => Promise<Resolved<TReturnType>>\n}\n\nconst schedulerCache = /*#__PURE__*/ new Map<number | string, SchedulerItem[]>()\n\nexport function createBatchScheduler<\n  TParameters,\n  TReturnType extends readonly unknown[],\n>({\n  fn,\n  id,\n  shouldSplitBatch,\n  wait = 0,\n}: CreateBatchSchedulerArguments<\n  TParameters,\n  TReturnType\n>): CreateBatchSchedulerReturnType<TParameters, TReturnType> {\n  const exec = async () => {\n    const scheduler = getScheduler()\n    flush()\n\n    const args = scheduler.map(({ args }) => args)\n\n    if (args.length === 0) return\n\n    fn(args as TParameters[])\n      .then((data) => {\n        scheduler.forEach(({ pendingPromise }, i) =>\n          pendingPromise.resolve?.([data[i], data]),\n        )\n      })\n      .catch((err) => {\n        scheduler.forEach(({ pendingPromise }) => pendingPromise.reject?.(err))\n      })\n  }\n\n  const flush = () => schedulerCache.delete(id)\n\n  const getBatchedArgs = () =>\n    getScheduler().map(({ args }) => args) as TParameters[]\n\n  const getScheduler = () => schedulerCache.get(id) || []\n\n  const setScheduler = (item: SchedulerItem) =>\n    schedulerCache.set(id, [...getScheduler(), item])\n\n  return {\n    flush,\n    async schedule(args: TParameters) {\n      const pendingPromise: PendingPromise<TReturnType> = {}\n      const promise = new Promise<Resolved<TReturnType>>((resolve, reject) => {\n        pendingPromise.resolve = resolve\n        pendingPromise.reject = reject\n      })\n\n      const split = shouldSplitBatch?.([...getBatchedArgs(), args])\n\n      if (split) exec()\n\n      const hasActiveScheduler = getScheduler().length > 0\n      if (hasActiveScheduler) {\n        setScheduler({ args, pendingPromise })\n        return promise\n      }\n\n      setScheduler({ args, pendingPromise })\n      setTimeout(exec, wait)\n      return promise\n    },\n  } as unknown as CreateBatchSchedulerReturnType<TParameters, TReturnType>\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}