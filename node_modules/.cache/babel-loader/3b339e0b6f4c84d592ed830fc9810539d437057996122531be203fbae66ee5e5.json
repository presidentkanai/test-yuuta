{"ast":null,"code":"import { InvalidAbiParametersError } from '../index.js';\nimport { isStructSignature, modifiers } from './runtime/signatures.js';\nimport { parseStructs } from './runtime/structs.js';\nimport { splitParameters } from './runtime/utils.js';\nimport { parseAbiParameter as parseAbiParameter_ } from './runtime/utils.js';\nexport function parseAbiParameters(params) {\n  const abiParameters = [];\n  if (typeof params === 'string') {\n    const parameters = splitParameters(params);\n    const length = parameters.length;\n    for (let i = 0; i < length; i++) {\n      abiParameters.push(parseAbiParameter_(parameters[i], {\n        modifiers\n      }));\n    }\n  } else {\n    const structs = parseStructs(params);\n    const length = params.length;\n    for (let i = 0; i < length; i++) {\n      const signature = params[i];\n      if (isStructSignature(signature)) continue;\n      const parameters = splitParameters(signature);\n      const length = parameters.length;\n      for (let k = 0; k < length; k++) {\n        abiParameters.push(parseAbiParameter_(parameters[k], {\n          modifiers,\n          structs\n        }));\n      }\n    }\n  }\n  if (abiParameters.length === 0) throw new InvalidAbiParametersError({\n    params\n  });\n  return abiParameters;\n}","map":{"version":3,"names":["InvalidAbiParametersError","isStructSignature","modifiers","parseStructs","splitParameters","parseAbiParameter","parseAbiParameter_","parseAbiParameters","params","abiParameters","parameters","length","i","push","structs","signature","k"],"sources":["/Users/kanaiyuuta/Downloads/test-yuuta-main/node_modules/viem/node_modules/abitype/src/human-readable/parseAbiParameters.ts"],"sourcesContent":["import type { AbiParameter } from '../abi.js'\nimport { InvalidAbiParametersError } from '../index.js'\nimport type { Narrow } from '../narrow.js'\nimport type { Error, Filter } from '../types.js'\nimport { isStructSignature, modifiers } from './runtime/signatures.js'\nimport { parseStructs } from './runtime/structs.js'\nimport { splitParameters } from './runtime/utils.js'\nimport { parseAbiParameter as parseAbiParameter_ } from './runtime/utils.js'\nimport type { IsStructSignature, Modifier } from './types/signatures.js'\nimport type { ParseStructs } from './types/structs.js'\nimport type { SplitParameters } from './types/utils.js'\nimport type { ParseAbiParameters as ParseAbiParameters_ } from './types/utils.js'\n\n/**\n * Parses human-readable ABI parameters into {@link AbiParameter}s\n *\n * @param TParams - Human-readable ABI parameters\n * @returns Parsed {@link AbiParameter}s\n *\n * @example\n * type Result = ParseAbiParameters('address from, address to, uint256 amount')\n * //   ^? type Result: [{ type: \"address\"; name: \"from\"; }, { type: \"address\";...\n *\n * @example\n * type Result = ParseAbiParameters<\n *   // ^? type Result: [{ type: \"tuple\"; components: [{ type: \"string\"; name:...\n *   ['Baz bar', 'struct Baz { string name; }']\n * >\n */\nexport type ParseAbiParameters<\n  TParams extends string | readonly string[] | readonly unknown[],\n> =\n  | (TParams extends string\n      ? TParams extends ''\n        ? never\n        : string extends TParams\n        ? readonly AbiParameter[]\n        : ParseAbiParameters_<SplitParameters<TParams>, { Modifier: Modifier }>\n      : never)\n  | (TParams extends readonly string[]\n      ? string[] extends TParams\n        ? AbiParameter // Return generic AbiParameter item since type was no inferrable\n        : ParseStructs<TParams> extends infer Structs\n        ? {\n            [K in keyof TParams]: TParams[K] extends string\n              ? IsStructSignature<TParams[K]> extends true\n                ? never\n                : ParseAbiParameters_<\n                    SplitParameters<TParams[K]>,\n                    { Modifier: Modifier; Structs: Structs }\n                  >\n              : never\n          } extends infer Mapped extends readonly unknown[]\n          ? Filter<Mapped, never>[0] extends infer Result\n            ? Result extends undefined\n              ? never\n              : Result\n            : never\n          : never\n        : never\n      : never)\n\n/**\n * Parses human-readable ABI parameters into {@link AbiParameter}s\n *\n * @param params - Human-readable ABI parameters\n * @returns Parsed {@link AbiParameter}s\n *\n * @example\n * const abiParameters = parseAbiParameters('address from, address to, uint256 amount')\n * //    ^? const abiParameters: [{ type: \"address\"; name: \"from\"; }, { type: \"address\";...\n *\n * @example\n * const abiParameters = parseAbiParameters([\n *   //  ^? const abiParameters: [{ type: \"tuple\"; components: [{ type: \"string\"; name:...\n *   'Baz bar',\n *   'struct Baz { string name; }',\n * ])\n */\nexport function parseAbiParameters<\n  TParams extends string | readonly string[] | readonly unknown[],\n>(\n  params: Narrow<TParams> &\n    (\n      | (TParams extends string\n          ? TParams extends ''\n            ? Error<'Empty string is not allowed.'>\n            : unknown\n          : never)\n      | (TParams extends readonly string[]\n          ? TParams extends readonly [] // empty array\n            ? Error<'At least one parameter required.'>\n            : string[] extends TParams\n            ? unknown\n            : unknown // TODO: Validate param string\n          : never)\n    ),\n): ParseAbiParameters<TParams> {\n  const abiParameters: AbiParameter[] = []\n  if (typeof params === 'string') {\n    const parameters = splitParameters(params)\n    const length = parameters.length\n    for (let i = 0; i < length; i++) {\n      abiParameters.push(parseAbiParameter_(parameters[i]!, { modifiers }))\n    }\n  } else {\n    const structs = parseStructs(params as readonly string[])\n    const length = params.length as number\n    for (let i = 0; i < length; i++) {\n      const signature = (params as readonly string[])[i]!\n      if (isStructSignature(signature)) continue\n      const parameters = splitParameters(signature)\n      const length = parameters.length\n      for (let k = 0; k < length; k++) {\n        abiParameters.push(\n          parseAbiParameter_(parameters[k]!, { modifiers, structs }),\n        )\n      }\n    }\n  }\n\n  if (abiParameters.length === 0)\n    throw new InvalidAbiParametersError({ params })\n\n  return abiParameters as ParseAbiParameters<TParams>\n}\n"],"mappings":"AACA,SAASA,yBAAyB,QAAQ,aAAa;AAGvD,SAASC,iBAAiB,EAAEC,SAAS,QAAQ,yBAAyB;AACtE,SAASC,YAAY,QAAQ,sBAAsB;AACnD,SAASC,eAAe,QAAQ,oBAAoB;AACpD,SAASC,iBAAiB,IAAIC,kBAAkB,QAAQ,oBAAoB;AAwE5E,OAAM,SAAUC,kBAAkBA,CAGhCC,MAcG;EAEH,MAAMC,aAAa,GAAmB,EAAE;EACxC,IAAI,OAAOD,MAAM,KAAK,QAAQ,EAAE;IAC9B,MAAME,UAAU,GAAGN,eAAe,CAACI,MAAM,CAAC;IAC1C,MAAMG,MAAM,GAAGD,UAAU,CAACC,MAAM;IAChC,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGD,MAAM,EAAEC,CAAC,EAAE,EAAE;MAC/BH,aAAa,CAACI,IAAI,CAACP,kBAAkB,CAACI,UAAU,CAACE,CAAC,CAAE,EAAE;QAAEV;MAAS,CAAE,CAAC,CAAC;;GAExE,MAAM;IACL,MAAMY,OAAO,GAAGX,YAAY,CAACK,MAA2B,CAAC;IACzD,MAAMG,MAAM,GAAGH,MAAM,CAACG,MAAgB;IACtC,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGD,MAAM,EAAEC,CAAC,EAAE,EAAE;MAC/B,MAAMG,SAAS,GAAIP,MAA4B,CAACI,CAAC,CAAE;MACnD,IAAIX,iBAAiB,CAACc,SAAS,CAAC,EAAE;MAClC,MAAML,UAAU,GAAGN,eAAe,CAACW,SAAS,CAAC;MAC7C,MAAMJ,MAAM,GAAGD,UAAU,CAACC,MAAM;MAChC,KAAK,IAAIK,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGL,MAAM,EAAEK,CAAC,EAAE,EAAE;QAC/BP,aAAa,CAACI,IAAI,CAChBP,kBAAkB,CAACI,UAAU,CAACM,CAAC,CAAE,EAAE;UAAEd,SAAS;UAAEY;QAAO,CAAE,CAAC,CAC3D;;;;EAKP,IAAIL,aAAa,CAACE,MAAM,KAAK,CAAC,EAC5B,MAAM,IAAIX,yBAAyB,CAAC;IAAEQ;EAAM,CAAE,CAAC;EAEjD,OAAOC,aAA4C;AACrD"},"metadata":{},"sourceType":"module","externalDependencies":[]}