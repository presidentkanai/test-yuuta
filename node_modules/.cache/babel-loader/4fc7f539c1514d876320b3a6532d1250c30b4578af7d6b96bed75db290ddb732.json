{"ast":null,"code":"import { multicall3Abi } from '../../constants/abis.js';\nimport { AbiDecodingZeroDataError } from '../../errors/abi.js';\nimport { BaseError } from '../../errors/base.js';\nimport { RawContractError } from '../../errors/contract.js';\nimport { decodeFunctionResult } from '../../utils/abi/decodeFunctionResult.js';\nimport { encodeFunctionData } from '../../utils/abi/encodeFunctionData.js';\nimport { getChainContractAddress } from '../../utils/chain.js';\nimport { getContractError } from '../../utils/errors/getContractError.js';\nimport { readContract } from './readContract.js';\n/**\n * Similar to [`readContract`](https://viem.sh/docs/contract/readContract.html), but batches up multiple functions on a contract in a single RPC call via the [`multicall3` contract](https://github.com/mds1/multicall).\n *\n * - Docs: https://viem.sh/docs/contract/multicall.html\n *\n * @param client - Client to use\n * @param parameters - {@link MulticallParameters}\n * @returns An array of results with accompanying status. {@link MulticallReturnType}\n *\n * @example\n * import { createPublicClient, http, parseAbi } from 'viem'\n * import { mainnet } from 'viem/chains'\n * import { multicall } from 'viem/contract'\n *\n * const client = createPublicClient({\n *   chain: mainnet,\n *   transport: http(),\n * })\n * const abi = parseAbi([\n *   'function balanceOf(address) view returns (uint256)',\n *   'function totalSupply() view returns (uint256)',\n * ])\n * const results = await multicall(client, {\n *   contracts: [\n *     {\n *       address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2',\n *       abi,\n *       functionName: 'balanceOf',\n *       args: ['0xA0Cf798816D4b9b9866b5330EEa46a18382f251e'],\n *     },\n *     {\n *       address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2',\n *       abi,\n *       functionName: 'totalSupply',\n *     },\n *   ],\n * })\n * // [{ result: 424122n, status: 'success' }, { result: 1000000n, status: 'success' }]\n */\nexport async function multicall(client, args) {\n  var _client$batch;\n  const {\n    allowFailure = true,\n    batchSize: batchSize_,\n    blockNumber,\n    blockTag,\n    contracts,\n    multicallAddress: multicallAddress_\n  } = args;\n  const batchSize = batchSize_ !== null && batchSize_ !== void 0 ? batchSize_ : typeof ((_client$batch = client.batch) === null || _client$batch === void 0 ? void 0 : _client$batch.multicall) === 'object' && client.batch.multicall.batchSize || 1024;\n  let multicallAddress = multicallAddress_;\n  if (!multicallAddress) {\n    if (!client.chain) throw new Error('client chain not configured. multicallAddress is required.');\n    multicallAddress = getChainContractAddress({\n      blockNumber,\n      chain: client.chain,\n      contract: 'multicall3'\n    });\n  }\n  const chunkedCalls = [[]];\n  let currentChunk = 0;\n  let currentChunkSize = 0;\n  for (let i = 0; i < contracts.length; i++) {\n    const {\n      abi,\n      address,\n      args,\n      functionName\n    } = contracts[i];\n    try {\n      const callData = encodeFunctionData({\n        abi,\n        args,\n        functionName\n      });\n      currentChunkSize += (callData.length - 2) / 2;\n      // Check to see if we need to create a new chunk.\n      if (\n      // Check if batching is enabled.\n      batchSize > 0 &&\n      // Check if the current size of the batch exceeds the size limit.\n      currentChunkSize > batchSize &&\n      // Check if the current chunk is not already empty.\n      chunkedCalls[currentChunk].length > 0) {\n        currentChunk++;\n        currentChunkSize = (callData.length - 2) / 2;\n        chunkedCalls[currentChunk] = [];\n      }\n      chunkedCalls[currentChunk] = [...chunkedCalls[currentChunk], {\n        allowFailure: true,\n        callData,\n        target: address\n      }];\n    } catch (err) {\n      const error = getContractError(err, {\n        abi,\n        address,\n        args,\n        docsPath: '/docs/contract/multicall',\n        functionName\n      });\n      if (!allowFailure) throw error;\n      chunkedCalls[currentChunk] = [...chunkedCalls[currentChunk], {\n        allowFailure: true,\n        callData: '0x',\n        target: address\n      }];\n    }\n  }\n  const aggregate3Results = await Promise.allSettled(chunkedCalls.map(calls => readContract(client, {\n    abi: multicall3Abi,\n    address: multicallAddress,\n    args: [calls],\n    blockNumber,\n    blockTag,\n    functionName: 'aggregate3'\n  })));\n  const results = [];\n  for (let i = 0; i < aggregate3Results.length; i++) {\n    const result = aggregate3Results[i];\n    // If an error occurred in a `readContract` invocation (ie. network error),\n    // then append the failure reason to each contract result.\n    if (result.status === 'rejected') {\n      if (!allowFailure) throw result.reason;\n      for (let j = 0; j < chunkedCalls[i].length; j++) {\n        results.push({\n          status: 'failure',\n          error: result.reason,\n          result: undefined\n        });\n      }\n      continue;\n    }\n    // If the `readContract` call was successful, then decode the results.\n    const aggregate3Result = result.value;\n    for (let j = 0; j < aggregate3Result.length; j++) {\n      // Extract the response from `readContract`\n      const {\n        returnData,\n        success\n      } = aggregate3Result[j];\n      // Extract the request call data from the original call.\n      const {\n        callData\n      } = chunkedCalls[i][j];\n      // Extract the contract config for this call from the `contracts` argument\n      // for decoding.\n      const {\n        abi,\n        address,\n        functionName,\n        args\n      } = contracts[results.length];\n      try {\n        if (callData === '0x') throw new AbiDecodingZeroDataError();\n        if (!success) throw new RawContractError({\n          data: returnData\n        });\n        const result = decodeFunctionResult({\n          abi,\n          args,\n          data: returnData,\n          functionName\n        });\n        results.push(allowFailure ? {\n          result,\n          status: 'success'\n        } : result);\n      } catch (err) {\n        const error = getContractError(err, {\n          abi,\n          address,\n          args,\n          docsPath: '/docs/contract/multicall',\n          functionName\n        });\n        if (!allowFailure) throw error;\n        results.push({\n          error,\n          result: undefined,\n          status: 'failure'\n        });\n      }\n    }\n  }\n  if (results.length !== contracts.length) throw new BaseError('multicall results mismatch');\n  return results;\n}","map":{"version":3,"names":["multicall3Abi","AbiDecodingZeroDataError","BaseError","RawContractError","decodeFunctionResult","encodeFunctionData","getChainContractAddress","getContractError","readContract","multicall","client","args","_client$batch","allowFailure","batchSize","batchSize_","blockNumber","blockTag","contracts","multicallAddress","multicallAddress_","batch","chain","Error","contract","chunkedCalls","currentChunk","currentChunkSize","i","length","abi","address","functionName","callData","target","err","error","docsPath","aggregate3Results","Promise","allSettled","map","calls","results","result","status","reason","j","push","undefined","aggregate3Result","value","returnData","success","data"],"sources":["/Users/kanaiyuuta/Downloads/test-yuuta-main/node_modules/viem/actions/public/multicall.ts"],"sourcesContent":["import type { Address, Narrow } from 'abitype'\n\nimport type { Client } from '../../clients/createClient.js'\nimport type { Transport } from '../../clients/transports/createTransport.js'\nimport { multicall3Abi } from '../../constants/abis.js'\nimport { AbiDecodingZeroDataError } from '../../errors/abi.js'\nimport { BaseError } from '../../errors/base.js'\nimport { RawContractError } from '../../errors/contract.js'\nimport type { Chain } from '../../types/chain.js'\nimport type { ContractFunctionConfig } from '../../types/contract.js'\nimport type { Hex } from '../../types/misc.js'\nimport type {\n  MulticallContracts,\n  MulticallResults,\n} from '../../types/multicall.js'\nimport { decodeFunctionResult } from '../../utils/abi/decodeFunctionResult.js'\nimport {\n  type EncodeFunctionDataParameters,\n  encodeFunctionData,\n} from '../../utils/abi/encodeFunctionData.js'\nimport { getChainContractAddress } from '../../utils/chain.js'\nimport { getContractError } from '../../utils/errors/getContractError.js'\n\nimport type { CallParameters } from './call.js'\nimport { readContract } from './readContract.js'\n\nexport type MulticallParameters<\n  TContracts extends ContractFunctionConfig[] = ContractFunctionConfig[],\n  TAllowFailure extends boolean = true,\n> = Pick<CallParameters, 'blockNumber' | 'blockTag'> & {\n  allowFailure?: TAllowFailure\n  /** The maximum size (in bytes) for each calldata chunk. Set to `0` to disable the size limit. @default 1_024 */\n  batchSize?: number\n  contracts: Narrow<readonly [...MulticallContracts<TContracts>]>\n  multicallAddress?: Address\n}\n\nexport type MulticallReturnType<\n  TContracts extends ContractFunctionConfig[] = ContractFunctionConfig[],\n  TAllowFailure extends boolean = true,\n> = MulticallResults<TContracts, TAllowFailure>\n\n/**\n * Similar to [`readContract`](https://viem.sh/docs/contract/readContract.html), but batches up multiple functions on a contract in a single RPC call via the [`multicall3` contract](https://github.com/mds1/multicall).\n *\n * - Docs: https://viem.sh/docs/contract/multicall.html\n *\n * @param client - Client to use\n * @param parameters - {@link MulticallParameters}\n * @returns An array of results with accompanying status. {@link MulticallReturnType}\n *\n * @example\n * import { createPublicClient, http, parseAbi } from 'viem'\n * import { mainnet } from 'viem/chains'\n * import { multicall } from 'viem/contract'\n *\n * const client = createPublicClient({\n *   chain: mainnet,\n *   transport: http(),\n * })\n * const abi = parseAbi([\n *   'function balanceOf(address) view returns (uint256)',\n *   'function totalSupply() view returns (uint256)',\n * ])\n * const results = await multicall(client, {\n *   contracts: [\n *     {\n *       address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2',\n *       abi,\n *       functionName: 'balanceOf',\n *       args: ['0xA0Cf798816D4b9b9866b5330EEa46a18382f251e'],\n *     },\n *     {\n *       address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2',\n *       abi,\n *       functionName: 'totalSupply',\n *     },\n *   ],\n * })\n * // [{ result: 424122n, status: 'success' }, { result: 1000000n, status: 'success' }]\n */\nexport async function multicall<\n  TContracts extends ContractFunctionConfig[],\n  TChain extends Chain | undefined,\n  TAllowFailure extends boolean = true,\n>(\n  client: Client<Transport, TChain>,\n  args: MulticallParameters<TContracts, TAllowFailure>,\n): Promise<MulticallReturnType<TContracts, TAllowFailure>> {\n  const {\n    allowFailure = true,\n    batchSize: batchSize_,\n    blockNumber,\n    blockTag,\n    contracts,\n    multicallAddress: multicallAddress_,\n  } = args\n\n  const batchSize =\n    batchSize_ ??\n    ((typeof client.batch?.multicall === 'object' &&\n      client.batch.multicall.batchSize) ||\n      1_024)\n\n  let multicallAddress = multicallAddress_\n  if (!multicallAddress) {\n    if (!client.chain)\n      throw new Error(\n        'client chain not configured. multicallAddress is required.',\n      )\n\n    multicallAddress = getChainContractAddress({\n      blockNumber,\n      chain: client.chain,\n      contract: 'multicall3',\n    })\n  }\n\n  type Aggregate3Calls = {\n    allowFailure: boolean\n    callData: Hex\n    target: Address\n  }[]\n\n  const chunkedCalls: Aggregate3Calls[] = [[]]\n  let currentChunk = 0\n  let currentChunkSize = 0\n  for (let i = 0; i < contracts.length; i++) {\n    const { abi, address, args, functionName } = contracts[\n      i\n    ] as ContractFunctionConfig\n    try {\n      const callData = encodeFunctionData({\n        abi,\n        args,\n        functionName,\n      } as unknown as EncodeFunctionDataParameters)\n\n      currentChunkSize += (callData.length - 2) / 2\n      // Check to see if we need to create a new chunk.\n      if (\n        // Check if batching is enabled.\n        batchSize > 0 &&\n        // Check if the current size of the batch exceeds the size limit.\n        currentChunkSize > batchSize &&\n        // Check if the current chunk is not already empty.\n        chunkedCalls[currentChunk].length > 0\n      ) {\n        currentChunk++\n        currentChunkSize = (callData.length - 2) / 2\n        chunkedCalls[currentChunk] = []\n      }\n\n      chunkedCalls[currentChunk] = [\n        ...chunkedCalls[currentChunk],\n        {\n          allowFailure: true,\n          callData,\n          target: address,\n        },\n      ]\n    } catch (err) {\n      const error = getContractError(err as BaseError, {\n        abi,\n        address,\n        args,\n        docsPath: '/docs/contract/multicall',\n        functionName,\n      })\n      if (!allowFailure) throw error\n      chunkedCalls[currentChunk] = [\n        ...chunkedCalls[currentChunk],\n        {\n          allowFailure: true,\n          callData: '0x' as Hex,\n          target: address,\n        },\n      ]\n    }\n  }\n\n  const aggregate3Results = await Promise.allSettled(\n    chunkedCalls.map((calls) =>\n      readContract(client, {\n        abi: multicall3Abi,\n        address: multicallAddress!,\n        args: [calls],\n        blockNumber,\n        blockTag,\n        functionName: 'aggregate3',\n      }),\n    ),\n  )\n\n  const results = []\n  for (let i = 0; i < aggregate3Results.length; i++) {\n    const result = aggregate3Results[i]\n\n    // If an error occurred in a `readContract` invocation (ie. network error),\n    // then append the failure reason to each contract result.\n    if (result.status === 'rejected') {\n      if (!allowFailure) throw result.reason\n      for (let j = 0; j < chunkedCalls[i].length; j++) {\n        results.push({\n          status: 'failure',\n          error: result.reason,\n          result: undefined,\n        })\n      }\n      continue\n    }\n\n    // If the `readContract` call was successful, then decode the results.\n    const aggregate3Result = result.value\n    for (let j = 0; j < aggregate3Result.length; j++) {\n      // Extract the response from `readContract`\n      const { returnData, success } = aggregate3Result[j]\n\n      // Extract the request call data from the original call.\n      const { callData } = chunkedCalls[i][j]\n\n      // Extract the contract config for this call from the `contracts` argument\n      // for decoding.\n      const { abi, address, functionName, args } = contracts[\n        results.length\n      ] as ContractFunctionConfig\n\n      try {\n        if (callData === '0x') throw new AbiDecodingZeroDataError()\n        if (!success) throw new RawContractError({ data: returnData })\n        const result = decodeFunctionResult({\n          abi,\n          args,\n          data: returnData,\n          functionName,\n        })\n        results.push(allowFailure ? { result, status: 'success' } : result)\n      } catch (err) {\n        const error = getContractError(err as BaseError, {\n          abi,\n          address,\n          args,\n          docsPath: '/docs/contract/multicall',\n          functionName,\n        })\n        if (!allowFailure) throw error\n        results.push({ error, result: undefined, status: 'failure' })\n      }\n    }\n  }\n\n  if (results.length !== contracts.length)\n    throw new BaseError('multicall results mismatch')\n  return results as MulticallResults<TContracts, TAllowFailure>\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}