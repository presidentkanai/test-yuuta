{"ast":null,"code":"import { panicReasons } from '../../constants/solidity.js';\nimport { BaseError } from '../../errors/base.js';\nimport { ContractFunctionRevertedError } from '../../errors/contract.js';\n/*\n * @description Checks if error is a valid null result UniversalResolver error\n */\nexport function isNullUniversalResolverError(err, callType) {\n  var _cause$data, _cause$data2, _cause$reason;\n  if (!(err instanceof BaseError)) return false;\n  const cause = err.walk(e => e instanceof ContractFunctionRevertedError);\n  if (!(cause instanceof ContractFunctionRevertedError)) return false;\n  if (((_cause$data = cause.data) === null || _cause$data === void 0 ? void 0 : _cause$data.errorName) === 'ResolverNotFound') return true;\n  if (((_cause$data2 = cause.data) === null || _cause$data2 === void 0 ? void 0 : _cause$data2.errorName) === 'ResolverWildcardNotSupported') return true;\n  // Backwards compatibility for older UniversalResolver contracts\n  if ((_cause$reason = cause.reason) !== null && _cause$reason !== void 0 && _cause$reason.includes('Wildcard on non-extended resolvers is not supported')) return true;\n  // No primary name set for address.\n  if (callType === 'reverse' && cause.reason === panicReasons[50]) return true;\n  return false;\n}","map":{"version":3,"names":["panicReasons","BaseError","ContractFunctionRevertedError","isNullUniversalResolverError","err","callType","_cause$data","_cause$data2","_cause$reason","cause","walk","e","data","errorName","reason","includes"],"sources":["/Users/kanaiyuuta/Downloads/test-yuuta-main/node_modules/viem/utils/ens/errors.ts"],"sourcesContent":["import { panicReasons } from '../../constants/solidity.js'\nimport { BaseError } from '../../errors/base.js'\nimport { ContractFunctionRevertedError } from '../../errors/contract.js'\n\n/*\n * @description Checks if error is a valid null result UniversalResolver error\n */\nexport function isNullUniversalResolverError(\n  err: unknown,\n  callType: 'resolve' | 'reverse',\n): boolean {\n  if (!(err instanceof BaseError)) return false\n  const cause = err.walk((e) => e instanceof ContractFunctionRevertedError)\n  if (!(cause instanceof ContractFunctionRevertedError)) return false\n  if (cause.data?.errorName === 'ResolverNotFound') return true\n  if (cause.data?.errorName === 'ResolverWildcardNotSupported') return true\n  // Backwards compatibility for older UniversalResolver contracts\n  if (\n    cause.reason?.includes(\n      'Wildcard on non-extended resolvers is not supported',\n    )\n  )\n    return true\n  // No primary name set for address.\n  if (callType === 'reverse' && cause.reason === panicReasons[50]) return true\n  return false\n}\n"],"mappings":"AAAA,SAASA,YAAY,QAAQ,6BAA6B;AAC1D,SAASC,SAAS,QAAQ,sBAAsB;AAChD,SAASC,6BAA6B,QAAQ,0BAA0B;AAExE;;;AAGA,OAAM,SAAUC,4BAA4BA,CAC1CC,GAAY,EACZC,QAA+B;EAAA,IAAAC,WAAA,EAAAC,YAAA,EAAAC,aAAA;EAE/B,IAAI,EAAEJ,GAAG,YAAYH,SAAS,CAAC,EAAE,OAAO,KAAK;EAC7C,MAAMQ,KAAK,GAAGL,GAAG,CAACM,IAAI,CAAEC,CAAC,IAAKA,CAAC,YAAYT,6BAA6B,CAAC;EACzE,IAAI,EAAEO,KAAK,YAAYP,6BAA6B,CAAC,EAAE,OAAO,KAAK;EACnE,IAAI,EAAAI,WAAA,GAAAG,KAAK,CAACG,IAAI,cAAAN,WAAA,uBAAVA,WAAA,CAAYO,SAAS,MAAK,kBAAkB,EAAE,OAAO,IAAI;EAC7D,IAAI,EAAAN,YAAA,GAAAE,KAAK,CAACG,IAAI,cAAAL,YAAA,uBAAVA,YAAA,CAAYM,SAAS,MAAK,8BAA8B,EAAE,OAAO,IAAI;EACzE;EACA,KAAAL,aAAA,GACEC,KAAK,CAACK,MAAM,cAAAN,aAAA,eAAZA,aAAA,CAAcO,QAAQ,CACpB,qDAAqD,CACtD,EAED,OAAO,IAAI;EACb;EACA,IAAIV,QAAQ,KAAK,SAAS,IAAII,KAAK,CAACK,MAAM,KAAKd,YAAY,CAAC,EAAE,CAAC,EAAE,OAAO,IAAI;EAC5E,OAAO,KAAK;AACd"},"metadata":{},"sourceType":"module","externalDependencies":[]}